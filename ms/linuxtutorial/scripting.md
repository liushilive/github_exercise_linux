# Bash 脚本！

介绍
所以这是本教程的最后一节。在这里，我们将介绍一个称为脚本的概念。

这将简要介绍 Bash 脚本。你可以做更多的事情，但我的目标是让你开始并给你足够的工作量。

本节汇集了我们在前几节中学到的很多东西（你会经常看到它们）。如果其中一些东西没有意义，你可能需要回顾前面的部分并刷新你的记忆。

有关 Bash 脚本的更全面的了解，请参阅我们的 Bash 脚本编写教程。

那他们是什么？
计算术语中的 Bash 脚本类似于戏剧术语中的脚本。这是一份说明该做什么和做什么的文件。这里，不是由一个人读取和操作的脚本，而是由计算机读取和操作（或执行）它。

Bash 脚本允许我们定义一系列操作，然后计算机将执行这些操作，而无需我们自己输入命令。如果特定任务经常完成，或者它是重复的，那么脚本可以是一个有用的工具。

Bash 脚本由称为解释器的东西解释（读取和操作）。典型的 Linux 系统上有各种解释器，但我们一直在学习 Bash shell，所以我们将在这里介绍 bash 脚本。

你可以在命令行上运行的任何内容都可以放入脚本中，它们的行为完全相同。反之亦然，你可以在脚本中添加任何内容，你可以在命令行上运行，并且它将执行完全相同的操作。

在创建脚本时，上述声明非常重要。在测试脚本的不同部分时，在构建脚本时，通常最简单的方法就是直接在命令行上运行命令。

脚本只是一个纯文本文件，它可能有你喜欢的任何名称。你可以像创建任何其他文本文件一样创建它们，只需使用普通的旧文本编辑器（例如我们在第 6 节中查看的 VI）。

一个简单的例子
下面是一个简单的脚本。我建议你自己创建一个类似的文件并运行它以了解它们的工作方式。该脚本将在屏幕上打印一条消息（使用一个名为 echo 的程序），然后给我们列出当前目录中的内容。

echo <message>

猫 myscript.sh
＃！/ 斌 / 庆典
＃一个简单的演示脚本

# Ryan 22/5/2019

echo 以下是当前目录中的文件：
LS
ls -l myscript.sh
-rwxr-xr-x 1 ryan 用户 2012 年 6 月 4 日 myscript.sh
./myscript.sh
以下是当前目录中的文件：
barry.txt bob example.png firstfile foo1 myoutput video.mpeg
让我们分解一下：

第 1 行让我们先来看一下我们的脚本吧。Linux 是一个无扩展的系统，因此脚本不需要具有。sh 扩展名。然而，通常将它们放在上面以便于识别。
第 2 行脚本的第一行应该始终是这一行。该行标识应使用哪个解释器。前两个字符被称为 shebang。之后（重要的是，没有空格）是解释器的路径。
第 3 行和第 4 行＃之后的任何内容都是注释。翻译不会运行这个，它只是为了我们的利益。最好包括你的姓名，编写脚本的日期以及脚本顶部的一行快速描述。
第 6 行我们将使用一个名为 echo 的程序 它只会将它后面的任何内容（作为命令行参数）打印到屏幕上。用于打印消息。
第 7 行我们脚本的下一步是打印当前目录的内容。
第 9 行脚本必须具有执行权限才能运行。在这里，我只是证明该文件具有正确的权限。.
第 12 行现在我们运行脚本。我会解释为什么我们需要进一步降低。/
第 13 行和第 14 行运行（或执行）脚本的输出。
唷。那里有很多重要的要点。现在让我们更详细地看一下它们。

重点
Shebang
脚本的第一行应告诉系统应该在此文件上使用哪个解释器。重要的是，这是脚本的第一行。没有空间也很重要。前两个字符＃！（shebang）告诉系统，它将直接用于解释器的使用路径。如果我们不知道我们的翻译位于那么我们可以使用一个被称为它找出来。

哪个<program>

哪个 bash
/ 斌 / 庆典
哪个
的 / usr / bin 中 / LS
如果我们离开这一行，那么我们的 Bash 脚本可能仍然有用。如果没有指定 shell，大多数 shell（包括 bash）将假定它们是解释器。但是，总是包括解释器是一种好习惯。稍后，你或其他人可能会在 bash 不是当前正在使用的 shell 的情况下运行你的脚本，这可能会导致不希望的结果。

名字
Linux 是一个无扩展的系统。这意味着我们可以随心所欲地调用我们的脚本，它不会影响它以任何方式运行。虽然通常在我们的脚本上放置。sh 扩展名，但这纯粹是为了方便而不是必需的。我们可以简单地将我们的脚本命名为 myscript 甚至是 myscript.jpg，它仍然可以很愉快地运行。

评论
注释只是脚本中没有运行的注释，它只是为了你的利益。注释很容易放入，你需要做的就是放置一个哈希（＃），然后将其视为注释。注释可以是整行或行尾。

猫 myscript.sh
＃！/ 斌 / 庆典
＃一条占据整行的评论
ls＃在行尾的评论
通常的做法是在脚本的顶部包含注释，其中包含脚本执行操作的简要说明以及编写脚本的人员以及何时编写脚本。这些只是人们通常希望了解脚本的基本内容。

对于脚本的其余部分，没有必要对每一行进行注释。大多数行都是自我解释的。仅对重要行放置注释或解释其操作可能不会立即明显的特定命令。

为什么 。/ ？
Linux 的设置方式基本上是出于逻辑原因。这种特性实际上使我们的系统更加安全。首先是一些背景知识。当我们在命令行上键入命令时，系统会运行预设的一系列目录，查找我们指定的程序。我们可以通过查看特定的变量 PATH 来找到这些目录（下一节将详细介绍）。

echo $ PATH
在 / usr / local / bin 目录：在 / usr / bin 中：/ bin 中：在 / usr / bin 中 / X11：在 / usr / X11R6 / bin 中：在 / usr / 游戏：/ usr / lib 中 / MIT / 斌：/ usr / lib 中 / MIT / sbin 目录
系统将查看第一个目录，如果找到程序，它将运行它，如果不是，它将检查第二个目录，依此类推。目录由冒号（:) 分隔。

系统不会查看除这些目录之外的任何目录，它甚至不会查看当前目录。但是，我们可以通过提供路径来覆盖此行为。当我们这样做时，系统有效地说“啊，你告诉我在哪里寻找脚本，所以我将忽略 PATH 并直接转到你指定的位置。” 你将从第 2 节（基本导航）中记得，句号（。）表示我们当前的目录，所以当我们说。/myscript.sh 时我们实际上是在调用系统以查看当前目录以查找脚本。我们也可以使用一个绝对路径（/home/ryan/linuxtutorialwork/myscript.sh），如果我们当前与脚本不在同一个目录中，它会完全相同或相对路径（../ linuxtutorialwork / myscript.sh）。

如果没有这种机制可以在当前目录中运行脚本，那么例如，某人可以很容易地在特定目录中创建恶意脚本并将其命名为 ls 或类似名称。如果他们想要查看该目录中的内容，人们会无意中运行它。

权限
脚本必须具有执行权限才能运行它（即使我们是文件的所有者）。出于安全原因，默认情况下你没有执行权限，因此你必须添加它。运行以确保脚本设置正确的良好命令是 chmod 755 <script>。

变量
变量是简单数据的容器。如果我们需要计算出特定的东西然后再使用它们，它们就很有用。变量很容易设置和引用，但它们具有特定的语法，必须严格遵循它们才能工作。

当我们设置变量时，我们指定它的名称，然后直接跟一个等号（=），后面跟着值。（所以，= 符号的两边都没有空格。）
当我们引用变量时，我们必须在变量名之前放置一个美元符号（$）。
一个简单的例子。

cat variableexample.sh
＃！/ 斌 / 庆典
＃变量的简单演示

# Ryan 22/5/2019

NAME = '瑞恩'
echo Hello $ name
./variableexample.sh
瑞恩你好
命令行参数和更多
当我们运行脚本时，有几个变量会自动为我们设置。这里是其中的一些：

$ 0 - 脚本的名称。
$ 1 - $ 9 - 给脚本的任何命令行参数。$ 1 是第一个参数，$ 2 是第二个参数，依此类推。
$＃ - 为脚本提供了多少个命令行参数。
$ * - 所有命令行参数。
还有其他变量，但这些应该足以让你现在开始。

cat morevariables.sh
＃！/ 斌 / 庆典
＃变量的简单演示

# Ryan 22/5/2019

echo 我的名字是 0 美元，我得到了 $＃命令行参数
echo 这里是：$ *
echo 和第二个命令行参数是 2 美元
./morevariables.sh bob fred sally
我的名字是 morevariables.sh，我得到了 3 个命令行参数
他们在这里：bob fred sally
第二个命令行参数是 fred
返回蜱虫
也可以将命令的输出保存到变量中，我们使用的机制就是反引号（`）（注意它是一个反引号而不是单引号。通常你会在键盘上找到反引号 1（一）键的左边。）这是一个例子。

cat backticks.sh
＃！/ 斌 / 庆典
＃使用反引号的简单演示

# Ryan 22/5/2019

lines =`cat $ 1 | wc -l`
echo $ 1 文件中的行数是 $ lines
./backticks.sh testfile.txt
testfile.txt 文件中的行数为 12
示例备份脚本
现在让我们把迄今为止学到的东西放到一个实际上有用的脚本中。我将所有项目保存在我的主目录中名为 projects 的目录中的不同目录中。我经常对这些项目进行备份，并将它们保存在我的主目录中名为 projectbackups 的目录中的日期文件夹中。

cat projectbackup.sh
＃！/ 斌 / 庆典
＃备份单个项目目录

# Ryan 22/5/2019

date =`date +％F`
mkdir~ / projectbackups / $ 1_ $ date
cp -R~ / projects / $ 1~ / projectbackups / $ 1_ $ date
完成 $ 1 的 echo 备份
./projectbackup.sh ocelot
ocelot 备份完成
你会注意到我在上面的脚本中使用了相对路径。通过这样做，我使脚本更通用。如果我的一个同事希望使用它，我可以给他们一份副本，它可以在没有修改的情况下为他们工作。你应该始终考虑使脚本具有灵活性和通用性，以便其他用户可以轻松使用它们或适应类似情况。你的脚本越可重用，时间越长，你需要做的工作就越少：)

如果声明
所以上面的备份脚本让我的生活变得更轻松，但如果我犯了错误呢？脚本可能会在一堆错误消息中丢失。在下面的例子中，我将介绍 if 语句。我只会简单地谈谈它们。你应该能够从下面的示例和注释中找出它们的用法。如果你想了解更多信息，请查看我们的 Bash Scripting Tutorial，它将详细介绍。

（如果这一切看起来太令人困惑，请不要太担心。即使只有上述知识，你仍然可以编写非常有用和实用的脚本来让你的生活更轻松。）

cat projectbackup.sh
＃！/ 斌 / 庆典
＃备份单个项目目录

# Ryan 22/5/2019

如果 [$＃！= 1]
然后
    echo 用法：单个参数，即备份目录
    出口
科幻
如果 [！-d~ / projects / $ 1]
然后
    echo'给定的目录似乎不存在（可能错字？）'
    出口
科幻
date =`date +％F`

＃我们今天有一个备份文件夹吗？
if [-d~ / projectbackups / $ 1_ $ date]
然后
    echo'这个项目今天已经备份了，覆盖了？'
    读答案
    如果 [$ answer！='y']
    然后
        出口
    科幻
其他
    mkdir~ / projectbackups / $ 1_ $ date
科幻
cp -R~ / projects / $ 1~ / projectbackups / $ 1_ $ date
完成 $ 1 的 echo 备份
让我们分解一下：

第 6 行我们的第一个 if 语句。格式化很重要。请注意空格是否正常工作所需。在这个语句中，我们询问参数的数量（$＃）是否不等于（！=）1。
第 8 行如果没有，那么脚本没有被正确调用。打印一条消息，说明应如何使用它。
第 9 行因为脚本没有被正确调用，我们希望在继续之前退出脚本。
第 10 行为了表示 if 语句的结束，我们有一行在其上有 fi（如果是向后）。
第 11 行如果语句可以测试很多不同的东西。这里的感叹号（！）表示不是，-d 表示“路径存在且是目录”。因此该行显示为“如果给定目录不存在”
第 22 行可以询问用户输入。我们使用的命令是读取的。read 接受一个参数，该参数是存储答案的变量。
第 23 行让我们看看用户如何响应并采取相应的行动。
你会注意到上面的代码中缩进了某些行。这不是必需的，但通常被认为是良好的做法，因为它使代码更容易阅读。

如果语句实际上使用了一个名为 test 的命令。如果你想了解可能执行的所有不同比较，请查看测试手册页。

这是对 Bash Scripting 的一个非常简短的介绍。有关 Bash 脚本的更全面的了解，请参阅我们的 Bash 脚本编写教程。

摘要
＃！
家当。指示应该运行脚本的解释器。
回声
在屏幕上打印一条消息。
哪一个
告诉你特定程序的路径。
$
当我们引用变量名的值时，将它放在变量名之前。
``
反引号。用于将程序的输出保存到变量中。
日期
打印日期。
if [] then else fi
执行基本条件逻辑。
表现一样
你可以在命令行上执行的任何操作，你可以在脚本中执行，它的行为将完全相同。
格式化
在格式化时，Bash 脚本特别挑剔。确保将空间放在需要的地方，不要在不需要时放置。
活动
让我们自动化：

要解决这些活动，你需要将本节和前面所有部分的技能和知识汇集在一起​​。

首先，考虑编写自己的备份脚本。你可以根据自己的喜好将其设为简单或复杂。也许从一个非常简单的开始，逐步改进它。
现在看看你是否可以编写一个脚本来为你提供有关给定目录的报告。你可以报告的事情包括
目录中有多少个文件？
目录中有多少个目录？
什么是最大的文件？
什么是最近修改或创建的文件？
在目录中拥有文件的人员列表。
你能想到的任何其他东西。
